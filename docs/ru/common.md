# Язык программировая Paw

Paw - высокоуровневый язык программирования общего назначения сочетающий парадигмы процедурного и функционального программирования. Инструментарий включает в себя интерпретатор и оптимизирующий транслятор в язык программирования C++. Управление памятью осуществляться [сборщиком мусора?], а большинство типов данных является ссылочными.

Язык предназначен для разработки простых и безопасных приложения широкого применяемых для обработки и анализа данных, веб-разработки и разработки игр. Также хорошо подходит для обучения функциональному программированию, алгоритмам и структурам данных.

Код на языке Paw типобезопасен, компактный и минималистичный с автоматическим выводом типов. Сильная типизация с полным отсутствием неявного преобразования типов полностью исключает ошибки, связанные с их приведением. Язык поддерживает обобщенный типы, функции высшего порядка и алгебраические типы данных, позволяющие писать абстрактные обобщенные алгоритмы и параметризованные структуры данных. Код может быть формально верифицирован, доказывая свою типовую корректность.

## Базовая семантика

Синтаксис языка вдохновлен семействами языков ML и C, блоки кода ограничиваются фигурными скобками; используются стандартные наименования управляющих конструкций `if`, `else`, и `for`;
последовательность операция отделяеться символом `;`;

Идентификаторы могут содержать латинские буквы, цифры и знак подчеркивания.

### Переменные

Для объявления локальной переменной используется ключевое слово `let`.
`:` - символ присвания типа.
`=` - символ присваивания значение.

```rs
let x : int = 44;
```

В Paw по умолчанию все значения переменных являются константными, для возможности их изменять 
требуется специально помечать значения как изменяемые при помощи ключевого слова `mut`.

```rs
let mut x : int = 44;

x = x + 33; // 77
```

Язык способен автоматически выводить тип по контексту его дальнейшего использовании в программе,
но если будет обнаружена операция с не соответствующими типами данных, то компилятор выдаст ошибку.

```rs
let x = 3; // int

let y = 2; // int

let string = "3"

let z = x + y; // int

let u = x + string // Ошибка компиляции!
```


## Обьявление функции
```rs
let some_func arg1 arg2 = {
    ...
}

let some_func arg1 arg = ... // В случае однопоточного выполнения
```

## Обьявление функции со статически типизированными аргументами
```rs
let sum (a : int) (b : int) = a + b
```

## Вызов функций 
```rs
sum 1 2
```

## Лямбда функция
```rs
let some = \arg1 arg2 = arg1 + arg2
```

## Сокращеный синтаксис для лямбд с одним аргументом
```rs
let some = \ _ + 1 // _ - переменная
```

## Пайплайн
```rs
let some = 4 |> sum 2 |> sum 3

let some = sum 3 sum 2 4 // Тоже самое но без пайплайна

let some 4 |> sum _ 2 |> sum 3 _ // Тоже самое с явным указанием куда подставлять результат
```

## Передача функции как аргумента
```rs
let add_one (n : int) = n + 1

let some = map [1, 2, 3, 4] .add_one // Результат [2, 3, 4, 5]
```

## Обращение к функции модуля 
```rs
let l : Std.List int = Std.List.Empty
```
## Экспорт подмодуля 
```rs
type List : Std.List
```

## Экспорт всех функций модуля
```rs
let * = Std.List
type * : Std.List
```


## Паттерн матчинг
```rs
let matching_func arg = match arg {
    0 = true,
    1 = false,
    _ = true,
}
```
# Типы

## Обьявление типа
```rs
type TypeName : TypeDescription
```

## Обьявление псевдонимов для значения типа
```rs
type TypeName : Pseudo Type
```

## Пример псевдонима в реализации Option
```rs
type Option t : Some t | None
```

## Обьявление типа кортежа
```rs
type TypeName : TypeOne * TypeTwo * TypeThree // Сырое определение 

type TypeName : (TypeOne, TypeTwo, TypeThree) // Синтаксический сахар
```

## Пример реализации списков
```rs
type List t : Cons (t, List t) | Empty 
type List t : (t, List t) | Empty // Без псевдонима
```

## Пример тайпкласса
```rs
interface InterfaceName T {
    first_interface_function : `A -> `B,
    second_interface_function : `A -> `B,
}
```

## Пример тайпкласса функтора
```rs
interface Functor F {
    map : (`A -> `B) -> F `A -> F `B
}
```
## Пример реализации тайпкласса функтора для типов Option и List
```rs 
let Functor Option = {
    map f a = match a {
        Some v = Some f v,
        None = None,
    }
}

let Functor List = {
    map f l = match l {
        Cons (h, t) = (f h, map .f t),
        Empty = Empty
    }
}

```

## Ограничение аргумента типа
```rs
type SomeType (t : Int) : t
```

## Матчинг по типу
```rs
type SomeType t : match t {
    int : float,
    float : int
}
```

## Эксперементальные идеи

### Зависимые типы
#### Наброски списка хранящего свою длину
```rs
type List (n : Nat ) (t : Type) : match n { // Nat - обозначает натуральное число
    0 = (Empty, 0),
    n = ((t, n), List (n - 1) t)
}

type List (n : Nat) (t : Type) : (Cons n t, (List (n - 1) t | Empty)) 

type List (n : Nat) (t : Type) : 
    Cons n t * List (n - 1) t + Cons 1 t * Empty 
    => Cons n t * (List (n - 1) t + Empty)
    => (Cons n t, (List (n - 1) t | Empty)) // Доказательство для листа

let insert : List n t -> t -> List (n + 1) t
let insert list el = (el, list);

let lookup : List n t -> Range n -> t
let lookup (x, _) 0 = x;
let lookup (_, xs) i = lookup xs (i - 1)
```

#### Наброски списка не хранящего свою длину
```rs
type List t : (t, List t) | Empty

let length : List t -> n
let length (x, xs) = 1 + length xs
let length (x, Empty) = 1

let insert list el = (el, list)

let lookup : (l : List t) -> Range (length l) -> t
let lookup (x, _) 0 = x
let lookup (_, xs) i = lookup xs (i - 1)
```















